import os
import sys

import matplotlib.pyplot as plt
import seaborn;

seaborn.set_style('whitegrid')
import numpy

from pomegranate import *

from Practice.DiscreteDistributionCreator import createDiscDistList
from Practice.CSVDataReader import getCourseEvent

numpy.random.seed(0)
numpy.set_printoptions(suppress=True)

# This was originally written to take in 5 prereq courses that a 6th course grade was dependent on,
# but creation of the fake data for course6 conditional probability table was too difficult/not worth the time
# so a shortened data set of 2 prereq courses (2,985,984 vs 1,728 events) and a course6 conditional probability table
# was created.

# Bayesian Network explanation (as understood on Jun 08 2020)
# Using data along with the probabilities of each result occurring, states/nodes are created which represent
# the data labels (courses). These states are connected with edges which represent data dependencies (prereqs)
# and a directed acyclic tree is formed. Given specific complete or non complete data (grades for the courses), the
# data follows down the decision tree, taking into account each of the probabilities of each direction, and outputs
# the missing or end goal values (predicted grades) by choosing the most likely direction to travel (grade) based on
# the cumulative probabilities up to and/or after that branch point.
# However, there is more to be said about how this can create the structure and probabilities using only data.

# Code explanation
# Fake data is read in from csv's with the probability of each grade for the 2 prereq courses
#   This data is placed into "states" or "nodes" that include the name of the course and the data/probabilities
# A fake table of events and their probabilities called a conditional probability table is read in from a csv
#   [B, A-, B+, 0.25] means given course1 is B, course2 is A-, there is a 25% chance that course6 is B+
#   This also works with given course2 is A-, course6 is B+, there is a 25% chance that course1 is B
#   or any other combination of that same event data
#   This table should be generated by pomegranate, but in this practice it was created manually
#   A state is then created for course6
# The Bayesian Network model is then initiated and is given each of the previous states
# Edges are created and given to the model
#   The edges declare a data dependency used with the conditional probability table of course6
#   Basically, this is assigning the prereqs of a course, in the future this may include other relevant courses
#   This will likely need to be read from a csv instead of being hard coded
# The model is then baked to create the Bayesian Network with all the data, states, and edges
# The prediction data is then displayed in the console using some test examples

# Editable fake data located on google drive at \Summer_2020\BayesianNetwork\PracticeSampleData


# Creates discrete distribution and the states of courses with no course dependencies using course name and
# grade probabilities from csv
# Currently, the test csv has 5 of these courses - shortened version has 2 courses
courseDiscDistList, courseDiscDistStateList = createDiscDistList()

# List of probability events loaded from csv for course6 using fake event probabilities
course6_events = getCourseEvent()
print('Course6 Events for conditional probability table:\n')
print(type(course6_events))
print(course6_events)
# Course6 is dependent on course the 5 loaded in courses in courseDiscDistList - shortened version has 2 courses
course6 = ConditionalProbabilityTable(course6_events, courseDiscDistList)

# State objects hold both the distribution, and a high level name.
# In this case, course6 is dependent on other courses, so it uses a conditional probability
# instead of a discrete distribution of probabilities
s6 = State(course6, name="Course6")

# Create the Bayesian network object with a useful name
model = BayesianNetwork("ExampleCourses")

# Add the course states to the Bayesian network
for state in courseDiscDistStateList:
    model.add_state(state)

model.add_state(s6)

# Add edges which represent conditional dependencies, where the second node is
# conditionally dependent on the first node
# This example makes an edge from each of the 5 loaded in courses to course6 - shortened version has 2 courses
for state in courseDiscDistStateList:
    model.add_edge(state, s6)

# Finalizes the Bayesian Network structure
model.bake()

# Prints out the prediction and then the probabilities of the None values given as many other values as possible.
# The more values given, the more accurate the Bayesian network can predict the rest of the values.
# Input the grades of the courses as the following:
# Course1, Course2, Course3, Course4, Course5, Course6 - shortened version has only course1, course2, and course6
# print(model.predict_proba([['A', 'A', 'A', 'A', 'A', None]]))

print(model.predict([['A', 'A', None]]))
print("")
print(model.predict_proba([['A', 'A', None]]))
print("\n\n")

print(model.predict([['D+', None, 'D']]))
print("")
print(model.predict_proba([['D+', None, 'D']]))
print("\n\n")

print(model.predict([[None, None, 'A-']]))
print("")
print(model.predict_proba([[None, None, 'A-']]))
print("\n\n")

print(model.predict([[None, None, None]]))
print("")
print(model.predict_proba([[None, None, None]]))
print("\n\n")
